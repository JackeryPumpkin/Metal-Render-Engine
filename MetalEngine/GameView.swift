//
//  GameView.swift
//  MetalEngine
//
//  Created by Zachary Duncan on 8/25/19.
//  Copyright © 2019 Zachary Duncan. All rights reserved.
//

import MetalKit

class GameView: MTKView {
    struct Vertex {
        var position: float3
        var color: float4
    }
    
    var commandQueue: MTLCommandQueue!
    var renderPipelineState: MTLRenderPipelineState!
    var vertices: [Vertex] = []
    
    var vertexBuffer: MTLBuffer!
    
    required init(coder: NSCoder) {
        super.init(coder: coder)
        
        // Device is the representation of the GPU
        device = MTLCreateSystemDefaultDevice()
        
        // Clear Color is what is displayed between frames (covering the last image shown)
        clearColor = MTLClearColor(red: 0.43, green: 0.73, blue: 0.35, alpha: 1)
        
        // Needs to match output of Fragment Shader. bgra8Unorm is the most common
        colorPixelFormat = .bgra8Unorm
        
        // Command Queue is what processes the buffer information for each frame
        commandQueue = device?.makeCommandQueue()
        
        createRenderPipelineState()
        createVertices()
        createBuffers()
    }
    
    func createRenderPipelineState() {
        // An MTLLibrary object that contains Metal shading language source code that is compiled during the
        // app build process or at runtime from a text string
        let library = device?.makeDefaultLibrary()
        
        // The String arg in the makeFunction(name:) needs to correspond exactly with the
        // intended function name in the Metal file
        let vertexFunction = library?.makeFunction(name: "basic_vertex_shader")
        let fragmentFunction = library?.makeFunction(name: "basic_fragment_shader")
        
        // An argument of options you pass to a device to get a render pipeline state object
        let renderPipelineDescriptor = MTLRenderPipelineDescriptor()
        
        // colorAttachments at 0th is the Rendering Color Attachement and must match self.colorPixelFormat
        renderPipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm
        renderPipelineDescriptor.vertexFunction = vertexFunction
        renderPipelineDescriptor.fragmentFunction = fragmentFunction
        
        do {
            renderPipelineState = try device?.makeRenderPipelineState(descriptor: renderPipelineDescriptor)
        } catch let error as NSError {
            print(error)
        }
    }
    
    func createVertices() {
        vertices = [
            Vertex(position: float3(0, 1, 0), color: float4(1, 0, 0, 1)),
            Vertex(position: float3(-1, -1, 0), color: float4(0, 1, 0, 1)),
            Vertex(position: float3(1, -1, 0), color: float4(0, 0, 1, 1))
        ]
    }
    
    func createBuffers() {
        vertexBuffer = device?.makeBuffer(bytes: vertices, length: MemoryLayout<Vertex>.stride * vertices.count, options: [])
    }
    
    override func draw(_ dirtyRect: NSRect) {
        // If all CAMetalDrawable objects are in use, the currentDrawable is nil.
        // The value of currentDrawable changes only after returning from one of the drawing functions.
        guard let drawable = currentDrawable else { return }
        
        // MTLRenderPassDescriptor object contains a collection of attachments that are the rendering destination
        // for pixels generated by a rendering pass. The MTLRenderPassDescriptor class is also used to set the
        // destination buffer for visibility information generated by a rendering pass.
        //
        // NOTE: currentRenderPassDescriptor is nil if the view’s device is not set or currentDrawable is nil
        guard let renderPassDescriptor = currentRenderPassDescriptor else { return }
        
        // An instruction given to a command queue
        let commandBuffer = commandQueue.makeCommandBuffer()
        
        // Command Encoder tells the command buffer what to do when it's committed.
        // There are 4 types:
        //   1. Render command   - Renders graphics to screen, vertex, fragment shader
        //   2. Compute command  - Does computational, mathematical tasks to be multithreaded on GPU
        //   3. Blit command     - Memory management tasks
        //   4. Parallel command - For doing multiple rendering tasks at a time
        let renderCommandEncoder = commandBuffer?.makeRenderCommandEncoder(descriptor: renderPassDescriptor)
        renderCommandEncoder?.setRenderPipelineState(renderPipelineState)
        
        // Send info to the renderCommandEncoder
        renderCommandEncoder?.setVertexBuffer(vertexBuffer, offset: 0, index: 0)
        renderCommandEncoder?.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: vertices.count)
        
        renderCommandEncoder?.endEncoding()
        commandBuffer?.present(drawable)
        commandBuffer?.commit()
    }
}
